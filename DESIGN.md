Le programme du jeu Platformer est essentiellement constitué d'une classe GameView, définie dans le module gameview.py, qui gère le fonctionnement du jeu et son affichage à travers ses différents attributs et les différentes méthodes qu'elle définit.


Le principal attribut de GameView est probablement l'attribut world, de la classe World définie dans le fichier map_create.create_world.py. Cette classe réunit sous ses attributs toutes les sprite_lists qui font partie du monde in-game (mais donc user interface exclus), incluant donc les sprites lists des walls, des no_go, des exit, des monstres, du joueur, etc. Inclure le joueur dans la class World est peut-être un peu moins intuitif dans le design, on pourrait peut-être voir le joueur simplement comme un attribut de gameview directement, mais ainsi la fonction read_map qui initialise en quelque sorte world "initialise" aussi le joueur, ainsi que le physics engine (qui est également un attribut de World). 

Parmi les attributs de World, peut-être pouvons nous arrêter sur la SpriteList monsters_list, qui a été la première chose qui nous a poussé à mettre en oeuvre les concepts de polymorphisme vus en cours dans notre projet. En effet, cette SpriteList prend des éléments de type "Monster", "Monster" étant une classe abstraite, dont héritent les classes Bat et Slime,servant principalement d'interface, mais permettant aussi d'éviter la duplication de code. En effet, les chauve-souris et les slimes partagent un certain nombre de caractéristiques, à savoir le fait de tuer le joueur lorsqu'ils entrent en contact avec ce dernier, de mourir des armes du joueur et de se déplacer. Mettre les deux classes dans une même Sprite_List était donc plutôt avantageux pour gérer d'une pierre deux coups les "check_for_collision_with_list" utilisés pour remplir certaines des fonctionnalités inhérentes aux monstres, et les faire hériter d'une même classe était aussi tout à fait cohérent dans le design. De même, bien que les mouvements respectifs des slimes et des chauve-souris suivent des logiques différentes, nous avons créé une abstract method dans Monster, ensuite implémentée dans les sous-classes Bats et Slimes, pour gérer les mouvements des monstres en une ligne dans la méthode on_update de GameView. Tout ceci est décrit dans le module monsters.py. Nous avons également pu mettre en pratique dans les classes Bats et Slimes d'autres concepts vus en cours, avec l'utilisation d'attributs de classe constants, pour la vitesse de chacun des types de monstre qui prend une valeur fixe et déterminée, mais trop intimement liée à la classe elle-même pour être déclarée comme une constante globale du module. De même, nous avons utilisé une property pour calculer la distance entre la chauve-souris et son point d'apparition. Il était utile d'avoir un attribut qui exprime une telle chose puisque nous désirions que la chauve souris ait un mouvement erratique qui ne dépasse pas les limites d'un cercle centré en son point d'apparition, donc qu'elle rebrousse chemin dès que sa distance à son point d'apparition excède une certaine valeur. Cependant cet attribut résulte d'une fonction de certains des autres attributs de Bat, et il paraissait donc logique de vouloir le faire émerger d'une méthode property.

Un autre ensemble de classes qui partage un peu le même schéma de polymorphisme est l'ensemble de classes qui définit les armes utilisées par le joueur, implémenté dans le module weapons.py. On a ainsi une classe Weapon, qui définit plusieurs méthodes qui gèrent les fonctionnalités communes entre l'épée et l'arc (en fait, surtout la position du sprite en fonction du joueur et de la souris) et dont héritent les classes Bow et Sword qui ont ensuite leur propre caractéristiques et attributs. De plus, pour l'épée, nous avons utilisé un héritage multiple, avec non seulement la classe Weapon, mais aussi la classe "Lethal", dont héritent les Sprites qui ont pour vocation de tuer les monstres. On évite ainsi la duplication de code de l'épée aux flèches pour la méthode qui check les collisions entre les armes léthales et les monstres, qui n'aurait pas pu être inclue dans la classe Weapon, puisque les arcs ne sont pas supposés tuer les monstres. 
Nous n'avons pas défini les flèches comme héritant de weapon car même si elles sont liées à l'arc, elles ont un comportement légèrement différent avant d'être relachées, notamment avec un angle par défaut du sprite différent qui implique de définir différement la position par rapport à la souris. Elles ont ainsi aussi leur propre sprite_list, auquel elles sont ajoutées lorsque'elles sont relâchées. Pour continuer sur les concepts vus en cours que nous avons mis en pratique dans notre projet, nous retrouvons ici aussi une property de classe, mais avec un rôle différent, puisque celle qui définit la speed de la flèche a ici uniquement un rôle d'encapsulation, avec un attribut de classe "__ARROW_SPEED" non immuable, puisque fonction de la charge de la flèche, mais que l'on rend privé puisque l'on veut ne pas pouvoir le modifier en dehors de la classe. Toutefois, on veut pouvoir accéder à cette valeur en dehors de la classe, ce qui justifie d'avoir une property "speed" égale à __ARROW_SPEED.

Du reste, nous avons dégagé certains sprites du World qui possédaient des caractéristiques suffisamment importantes pour qu'on en fasse des classes héritées de arcade.Sprite. La définition de ces classes sont réunies dans le fichier 'world_sprites_types', lui-même décomposé en modules, avec un module par classe. Chaque classe est définie de telle sorte qu'elle prenne automatiquement comme texture la texture qui correspond au type de Sprite, de sorte que l'initialisation soit allégée lors du readmap. En outre, chaque classe définit dans ses méthodes et attributs les fonctionnalités qu'on attend du sprite associé. Par exemple, nous avons ajouté comme extension un sprite checkpoint. En réalite, Checkpoint étend Collidable_Platform mais nous y reviendrons plus tard. Checkpoint a des attributs '__spawn_...' et 'linked map' qui permettent de remplir sa fonctionnalité de téléporter le joueur a sa position lorsqu'il meurt. '__spawn_...' est utile lorsque le checkpoint est sur une plateforme mouvante et que l'on veut la position d'origine et non celle ou le checkpoint se trouve actuellement.  Ces attributs sont inhérents aux Checkpoint, et justifient la création d'une classe. De la même facon, la méthode de classe 'set_respawn' satisfait une fonctionnalité propre aux sprites Checkpoint.

Intéressons nous maintenant au cas des plateformes. Pour délimiter la zone de mouvement des plateformes, nous avions besoin de stocker ces 'boundaries' quelques part. Nous avons donc créé une dataclass Trajectory qui remplissait précisément ce rôle. C'est une dataclass car ces boundaries ne sont rien de plus qu'un ensemble de données qui ont vocation à évoluer en même temps que le déroulement de l'algorithme de platform detecting. Ensuite, nous avons créé une sous-classe de Sprite, Platform qui prend une Trajectory en attribut, et a une méthode qui permet de transformer cette dataclass en boundaries, ce qu'arcade utilise pour le déplacement des plateformes
toutefois, en lisant notre code, vous aurez peut-être remarqué que certains de ces '"world_sprites_types" étendent une classe "Collidable_Platform" et d'autres non. Tout sprite qui peut être une plateforme mouvante et dont l'on veut pouvoir checker les collisions étend en fait cette classe. En effet, nous avons d'abord essayé de mettre tous les sprites que l'on voulait faire se déplacer dans la même spritelist "moving_platforms_list", avant de nous rendre compte que si l'ont mettait cette liste comme "platforms" du moteur physique, on ne pouvait plus checker les collisions avec les sprites a l'interieur de "moving_platforms_list". Pour la lave, les checkpoint, les interrupteurs et les exit nous avons donc du trouver une solution pour les faire se déplacer en conservant la propriété de collision. Nous avons donc implémenté nous-mêmes le système de déplacement, sans se soucier de l'interaction avec le joueur puisqu'il n'est pas censé marcher dessus. Toutefois, pour faire une telle chose, il était utile d'avoir une sous-classe de Plateformes, qui conserve l'attribut de type Trajectory, mais avec une méthode en plus qui gère le mouvement. Des lors, nous avons pu faire se déplacer ces sprites sans les mettre dans moving_platforms_list. Remarquez que même les exit, lava, checkpoint et switches qui ne sont pas voués à se déplacer sont de type Collidable_Platform. Nous avions pensé au début à faire par exemple pour Exit une classe Exit_sprite(Sprite) pour les exit immobiles et une classe 
Exit_Platform(Exit_Sprite, Collidable_Platform), mais cela aurait posé un problème puisqu'il y aurait eu deux inits dont on n'aurait pas pu se passer pour une même classe. Ainsi, même les sprites immobiles sont de type Collidable_Platform, simplement pour eux, la méthode movement() ne fait rien car ils n'ont pas de boundaries.

Nous pourrions détailler en détail la classe Player étant donné qu'il s'agit d'une classe importante du design de notre code, mais cela prendrait un peu de temps et elle ne fait qu'utiliser des concepts de programmation orienté objet dont nous avons déjà parlé précédemment. Un point intéressant à souligner est peut-être l'utilisation d'attributs de classe constants, tels que PLAYER_MOVEMENT_SPEED. En effet, il y avait plusieurs constantes immuables que nous aurions pu laisser comme constantes globales, mais que nous avons estimé trop lié à la classe Player pour l'en laisser dehors. 

Un autre attribut important de la classe GameView est l'attribut qui représente l'interface utilisateur (UI, ou user interface). En effet, au fur et à mesure que nous concevions notre projet, nous avons réalisé que nous voulions afficher plusieurs éléments à l'écran de manière fixe. Il sembalit donc pertinent de les réunir tous sous une même classe pour ne pas multiplier les attributs des GameView et avoir un endroit où gérer la logique de l'interface utilisateur. Enfin cela permettait d'avoir une meilleure modularisation et d'éviter d'accumuler des lignes de code dans gameview. (typiquement : avoir une méthode draw de user_interface pour draw toute l'interface utilisateur en une ligne dans le module gameview).

En parlant de modularisation, nous avons cherché à organiser nos fichiers de manière cohérente et en séparant bien les différents aspects du jeu mais sans multiplier les fichiers pour rien. Par exemple, il nous paraissait utile de séparer les worlds_sprites en plusieurs modules car nous ne trouvions pas vraiment de sous-division vraiment cohérente (a part switch et gate mais leur codes respectifs était suffisamment verbeux pour ne pas les mettre dans un même fichier). En revanche, nous avons pensé à mettre les monsters dans différentes classes mais cela aurait vite fait beaucoup de modules pour pas grand chose et nous désirions éviter de nous perdre dans un océan de fichiers et de dossiers.


Enfin, GameView n'est pas notre seule classe héritant de arcade.View. En effet, nous avons dégagé deux autres situations aux propriétés trop différentes pour simplement les implémenter comme une extension de GameView : le GameOver et l'écran de fin. Ainsi, parallèlement à GameView nous avons deux autres classes, EndGame et GameOverView (cf dossier alt_game_views), qui possèdent leur propre logique. En effet, il est prévu que dans ces deux écrans, la joueuse ne puisse pas intéragir avec le monde in-game, voire qu'il n'y ait pas du tout de monde (dans le cas de GameOver). Ces écrans sont donc en vue seule, et la seule interaction avec l'utilisateur se limite à sa possibilité de quitter l'écran en appuyant sur une touche précise. Cette logique différente justifiait l'utilisation de classes qui, bien qu'elles soient accédées à travers des méthodes de GameView, sont complètement externes à GameView. A noter toutefois que le GameOver s'initialise à travers le GameView originel puisque l'on veut pouvoir retourner au GameView une fois dans le GameOver, ce qui n'est pas le cas de EndGame. Pour le reste, les attributs d'EndGame et de GameOver servent uniquement pour l'interface visuelle et sonore.


En résumé on a les relations de classe :
-arcade.View:
    -GameView
    -EndGame
    -GameOverView

-arcade.Sprite :
    -Player
    -Coin
    -Gate
    -Monster(abstract):
        -Slime
        -Bat
    -Platform:
        -Collidable_Platform:
            -Checkpoint
            -Switch
            -Exit
            -Lava
    -Weapons(interface):
        -Bow
        -Sword  <---------Lethal (hérite de arcade.Sprite, se contente de définir la méthode kills)
                            /
    -Arrow <_______________/

-World 

-UI


-------------------------------------------

PERFORMANCES :

Complexité théorique:

Pour l'analyse de la complexité du chargement d'un niveau, nous avons choisi de nous intéresser au facteur du nombre total de sprites faisant partie de plateformes mouvantes. Ce facteur n'influe que sur la complexité de ce qui constitue l'algorithme block_detecting dans le module éponyme, et à la définition des limites de mouvement de la plateforme (define_boundaries). En effet, le reste de la fonction readmap ne s'intéresse pas aux plateformes, qui sont enlevées de la map au moment de l'application de l'algorithme block_detecting, et la complexité du reste de readmap est constante (θ(1)) par rapport au nombre de sprites de plateformes mouvantes. Nous nous intéresserons donc uniquement à la portion de la fonction readmap qui detecte les blocs et définit les limites de chaque plateforme.
Pour définir les limites de chaque plateforme, nous utilisons une boucle itérative sur l'ensemble des sprites qui sont des plateformes, puis appliquons une fonction de complexité constante, define_boundaries. Cette partie du code a donc une complexité 
Θ(n)Θ(c)=Θ(n) où n est le nombre de sprites-plateformes et c est le nombre constant d'opérations élémentaires dans define_boundaries.
Pour l'algorithme de block_detecting, nous avons une fonction récursive detect_block qui s'applique sur les 4 côtés de chaque sprite avant de se terminer. Ainsi, l'agorithme applique 4.n fois la fonction detect_block avant de se terminer. Cette fonction, a part s'appeler elle-meme sur les côtés adjacents, ne fait pas grand chose à part créer un nouveau Sprite, l'ajouter a une SpriteList et remplacer le caractère qui le représentait par " ". Ces opérations sont constantes en fonction du nombre total de sprites. La complexité théorique de l'algorithme block_detecting en lui-même est donc de Θ(c).Θ(4n) = Θ(n). 
Au total (define_boundaries et block_detecting combinés), la complexité algorithmique du chargement d'un niveau selon le nombre de sprites faisant partie d'une plateforme est de  
Θ(n+n) = Θ(n).
C'est assez satisfaisant puisque c'est équivalent à la complexité théorique relative au nombre de murs fixes, quand bien même l'algorithme gérant les plateformes est largment plus compliqué. Cependant on peut s'attendre à ce que les performances brutes descendent bien plus vites pour la gestion des plateformes que pour celle des murs fixes.



Pour l'analyse de la complexité du on_update, nous nous intéressons maintenant au facteur du nombre d'ennemis. Dans la fonction on_update de gameview, ce facteur intervient exactement 3 fois : lorsqu'on gère le déplacement des monstres (monster.movement()), lorsque l'on vérifié si une flèche doit tuer un monstre (arrow.kills_monster) et lorsque l'on vérifie si un joueur doit mourir d'une collision avec un monstre (player.dies()). Le reste de on_update est constant pour le nombre d'ennemis (Θ(1)). Intéressons-nous à la complexité de chacune de ces 3 méthodes :
D'abord monster.movement(). Cette méthode a deux déclarations différentes pour les chauve-souris et pour les slimes. Pour les chauve-souris, on se contente de remplacer un nombre constant d'attributs de la chauve-souris, ce qui se fait en Θ(1). Pour le slime, on change la position, mais on vérifie aussi à chaque appel de la méthode si les sprites "__below" et "__front" attribut du slime sont en collision avec un élément de wall_list. Cette stratégie peut sembler coûteuse, mais le fait que wall_list soit hashed spatialement rend l'opération de check_collision en Θ(1), et le coût en complexité théorique au moins est faible, et ainsi, la méthode movement() est en Θ(1) pour le slime également. Cette méthode étant appelée pour chaque ennemie à chaque on_update on se retrouve finalement avec une méthode Θ(n).
Deuxièmement, nous considèreons ensemble les méthodes player.dies() et arrow.kills_monster(), puisqu'elles agissent à peu près de la même manière : vérifier si le sprite sur lequel la méthode est appelée est en collision avec un élément de la liste des monstres (puis appliquer différentes opérations en conséquence mais ceci ne nous intéresse pas puisque ce sont des opérations constantes en fonction du nombre d'ennemis). Nous avons pris la décision de passer la monster_list en spatial_hash enabled ce qui rend le check_collision avec cette liste une opération en Θ(1) (d'après la bibliothèque arcade elle-même). Ainsi, ces deux méthodes sont toutes deux en Θ(1).
Au global, la méthode on_update est en Θ(n) avec n le nombre d'ennemis chargés sur la map, ce qui était probablement inévitable puisque nous devons gérer les mouvements de chaque monstre indépendamment, et reste intéressant. Maintenant, le choix d'avoir passé la monster_list en spatial_hashed est un trade-off qui bien qu'intéressant en terme de complexité théorique, a un certain coût en performances brutes puisque les monstres se déplacent et leur spatial_hashing doit donc être adapté en conséquence. Un profiling pourrait nous indiquer si ce trade-off était rentable ou pas, mais cela doit également dépendre du nombre d'ennemis que nous avons besoin de charger.



Benchmarks :
