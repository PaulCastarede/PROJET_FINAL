Le programme du jeu Platformer est essentiellement (même exclusivement) constitué d'une classe GameView, définie dans le module gameview.py, qui gère le fonctionnement du jeu et son affichage à travers ses différents attributs et les différentes méthodes qu'elle définit.


Le principal attribut de GameView est probablement l'attribut world, de la classe World définie dans le fichier Map_Create.create_world.py. Cette classe réunit sous ses attributs toutes les sprite_lists qui font partie du monde in-game (mais donc user interface exclus), incluant donc les sprites lists des walls, des no_go, des exit, des monstres, du joueur, etc. Inclure le joueur dans la class World est peut-être un peu moins intuitif dans le design, on pourrait peut-être voir le joueur simplement comme un attribut de gameview directement, mais ainsi la fonction read_map qui initialise en quelque sorte world "initialise" aussi le joueur, ainsi que le physics engine (qui est soit dit en passant également un attribut de World). 

Parmi les attributs de World, peut-être pouvons nous arrêter sur la SpriteList monsters_list, qui a été la première chose qui nous a poussé à mettre en oeuvre les concepts de polymorphisme vus en cours dans notre projet. En effet, cette SpriteList prend des éléments de type "Monster", "Monster" étant une classe abstraite, dont héritent les classes Bat et Slime,servant principalement d'interface, mais permettant aussi d'éviter la duplication de code. En effet, les chauve-souris et les slimes partagent un certain nombre de caractéristiques, à savoir le fait de tuer le joueur lorsqu'ils entrent en contact avec ce dernier, de mourir des armes du joueur et de se déplacer. Mettre les deux classes dans une même Sprite_List était donc plutôt avantageux pour gérer d'une pierre deux coups les "check_for_collision_with_list" utilisés pour remplir certaines des fonctionnalités inhérentes aux monstres, et les faire hériter d'une même classe était aussi tout à fait cohérent dans le design. De même, bien que les mouvements respectifs des slimes et des chauve-souris suivent des logiques différentes, nous avons créé une abstract method dans Monster, ensuite implémentée dans les sous-classes Bats et Slimes, pour gérer les mouvements des monstres en une ligne dans la méthode on_update de GameView. Tout ceci est décrit dans le module monsters.py. Nous avons également pu mettre en pratique dans les classes Bats et Slimes d'autres concepts vus en cours, avec l'utilisation d'attributs de classe constants, pour la vitesse de chacun des types de monstre qui prend une valeur fixe et déterminée, mais trop intimement liée à la classe elle-même pour être déclarée comme une constante globale du module. De même, nous avons utilisé une property pour calculer la distance entre la chauve-souris et son point d'apparition. Il était utile d'avoir un attribut qui exprime une telle chose puisque nous désirions que la chauve souris ait un mouvement erratique qui ne dépasse pas les limites d'un cercle centré en son point d'apparition, donc qu'elle rebrousse chemin dès que sa distance à son point d'apparition excède une certaine valeur. Cependant cet attribut résulte d'une fonction de certains des autres attributs de Bat, et il paraissait donc logique de vouloir le faire émerger d'une méthode property.

Un autre ensemble de classes qui partage un peu le même schéma de polymorphisme est l'ensemble de classes qui définit les armes utilisées par le joueur, implémenté dans le module weapons.py. On a ainsi une classe Weapon, qui définit plusieurs méthodes qui gèrent les fonctionnalités communes entre l'épée et l'arc (en fait, surtout la position du sprite en fonction du joueur et de la souris) et dont héritent les classes Bow et Sword qui ont ensuite leur propre caractéristiques et attributs. De plus, pour l'épée, nous avons utilisé un héritage multiple, avec non seulement la classe Weapon, mais aussi la classe "Lethal", dont héritent les Sprites qui ont pour vocation de tuer les monstres. On évite ainsi la duplication de code de l'épée aux flèches pour la méthode qui check les collisions entre les armes léthales et les monstres, qui n'aurait pas pu être inclue dans la classe Weapon, puisque les arcs ne sont pas supposés tuer les monstres. 
Nous n'avons pas défini les flèches comme héritant de weapon car même si elles sont liées à l'arc, elles ont un comportement légèrement différent avant d'être relachées, notamment avec un angle par défaut du sprite différent qui implique de définir différement la position par rapport à la souris. Elles ont ainsi aussi leur propre sprite_list, auquel elles sont ajoutées lorsque'elles sont relâchées. Pour continuer sur les concepts vus en cours que nous avons mis en pratique dans notre projet, nous retrouvons ici aussi une property de classe, mais avec un rôle différent, puisque celle qui définit la speed de la flèche a ici uniquement un rôle d'encapsulation, avec un attribut de classe "__ARROW_SPEED" non immuable, puisque fonction de la charge de la flèche, mais que l'on rend privé puisque l'on veut ne pas pouvoir le modifier en dehors de la classe. Toutefois, on veut pouvoir accéder à cette valeur en dehors de la classe, ce qui justifie d'avoir une property speed égale à __ARROW_SPEED.
